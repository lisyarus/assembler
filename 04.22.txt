Плохой-плохой gcc

    f = TryEnterCS();
    if (f)
        x++;
        
Переходит в 
    
    call TryEnterCS ; returns 0/1 false/true
    mov ecx, [x]
    add ecx, eax
    mov [x], ecx
    
В итоге критическая секция летит к хуям.

    Почему? Один тред прочитал x, увеличил, его прервали, второй тред увеличил несколько раз, первый тред записал старое.

Даже если без тредов: есть MMIO (memory mapped input/output). Некоторые адреса памяти забайндены на устройства => те же проблемы.

Барабанная дробь...

===== x86-64 =====

Появилось в Athlon64 - первое и единственное расширение от AMD, полностью поддержанное Intel.
Когда в 386 переходили с 16 бит в 32 бита, было не так уж и больно - программ немного, процессорных команд тоже.
Изначально Intel не хотел расширения, а хотел создать новое, светлое будущее в виде новой изначально 64-битной архмтектуры.
    МНого ненужных команд, много неприятных спецеффектов.
    Например: если команда сохраняет все флаги / меняет все флаги, перемешивать ее просто (просто поменял или запомнил, откуда их восстановить).
    Если часть меняет, а часть схраняет - перемешивать очень больно.

Itanium - новое, светлое 64-битное будущее.
Хомячки закукарекали "чтоооо, наши программы здесь не работают" и будущее не прижилось.

AMD сказал: мы сделаем расширение, в котором все старое будет работать, но будет еще 64-битный режим. Хомячкам понравилось.
Вышло расширение AMD64 (которое не очень-то имеет отношение к процессорам от AMD).
Но папочки с названием AMD64 хомячки принимали за что-то для AMD, поэтому их переименовали в что-нибудь типо x64.

Зачем нам 64 бита?
Закончилось 32-битное адресное пространство. И нет, 640 Кб хватит не всем.
PAE (physical address extension): в Pentium Pro были 36-битные адреса (это можно было делать за счет страшного сопоставления логических и физических адресов).
Программы адресовали все еще 32 битами, но ничто не мешает мэпить адресные пространства разных процессов в разные куски памяти.
AWE - позволяет создавать окно и руками переключать физические адреса, которые мэпятся в это окно. Страшно и неудобно.
А еще конец логической памяти отдан под устройства.
Самая грустная проблема: из-за фрагментированности адресного пространства (заметьте, не самой оперативки) при очередном выделении памяти у процесса просто не будет куска адресного пространства под выделенную память.
В Java, когда приходит сборщик мусора, он приостанавливает программу, сдвигает указатели, возвращает управление.
В (богоугодных) языках без менеджеров памяти ничего не сделать. Проблема.

== Итак, что нового. ==

Новый режим работы процессора.
Немного по-другому интерпретируются коды команд.
Регистры общего назначения расширены до 64 бит (EAX -> RAX и т.п.).
8 новых регистров: R8..R15 (R8D, R8W, R8B - младшие 4, 2, 1 байты соответственно).
Разрешено обращаться к младшей 8-битной части si, di, sp, bp: sil, dil, spl, bpl.
Использовать AH, BH и т.д. вместе с чем-то новым нельзя - нет таких опкодов.
    Под sil, dil и т.д. отдали место, которое было под ah и т.д., переключение по отдельному флажку в опкоде.
EIP -> RIP. Лол.

Новая адресация:
    [r??] + [r?? кроме rsp] * [2^0..3] + [signed 32-bit offset]
    rip + [signed 32-bit offset]

64-битных констант как не было, так и нет. Команды получатся слишком длинными, декодер станет медленно работать (+ ограничение 15 байт на команду).
Но: при записи из памяти в al/ax/eax/rax (или наоборот) можно использовать 64-битную константу как адрес памяти.
При прямой записи константы в регистр можно использовать 64-битную константу.

8 новых xmm регистров xmm8..15.

Переключать режим работы процессора - очень дорого.
Теперь есть режим long mode.
Есть флажок "текущая битность исполняемого кода", переключать который дешевле.
Профит: нативная поддержка и 32битного кода.

Выкинули часть команд, чтобы освободить опкоды для будущих (и текущих) расширений.
Например: 
    Команды двоично-десятичной арифметики (что?!) AAA, AAD, AAM, AAS, DAA, DAS.
    BOUND - предполагалась как что-нибудь в духе проверки границ индекса массива. При фейле срабатывает прерывание, что очень дорого и никто не использует.
    INTO - по тем же причинам.
    PUSHA(D), POPA(D) - слишком много регистров, нехрен.
    SALC
    LDS, LES
    PUSH/POP CS, ES, DS, SS
    ARPL
    JMP/CALL FAR ABS (дальние переходы, что это - в следующий раз)
    Короткая форма команд INC/DEC (этот опкод заменен на префикс REX, позволяющий всякие новые 64-битные плюшки)
    SYSENTER/SYSEXIT - механизм для системных вызовов (вместо дорогих прерываний)
        Jump в системынй код / из системного кода с переключением привелегий.
        Убрали потому что добавили SYSCALL/SYSRET.
        В действительности:
            В AMD есть все команды
            В Intel 64 bit тоже все
            
Изменение в работае команд:
    При записи в младшие 32 бита регистра старшие 32 бита обнуляются.
        Но: nop = xchg eax, eax должен занулить старшие 32 бита. Для xchg eax, eax исключение - она не обнуляет.
        
Calling conventions
Ровно 2 соглашения вызова
    fastcall64 от Microsoft
    unix64 (по факту используется просто везде, кроме Microsoft)

Обе подразумевают передачу первых нескольких аргументов в регистрах, остальные на стеке в обратном порядке, стек чистит тот, кто вызывает.
Перед call'ом rsp должен быть выровнен на 16 байт.
НИКАКИХ ПОДЧЕРКИВАНИЙ ПЕРЕД ИМЕНАМИ, ДАААААААА

fastcall64:
    rcx, rdx, r8, r9
        или
    xmm0..xmm3
    
    int, float, int, int: rcx, xmm1, r8, r9

    Сохранять: rbx, rbp, rsi, rdi, r12..15, xmm6..xmm15 (за последнее Microsoft нужно убивать, медленно и мучительно; зачем? судьба такая).

    Возвращаемое значение: rax или xmm0
    
    Фича: 32 бата над адресом возврата должно быть зарезервировано для вызываемой функции.
    Why? Because fuck you, that's why.
    Может быть, хочет выгрузить туда регистровые аргументы, или еще что-нибудь.

unix64:
    rdi, rsi, rdx, rcx (r10 для syscall), r8, r9
        и
    xmm0..xmm7
    
    int, float, int, int, float: rdi, xmm0, rsi, rdx, xmm1

    Если вызвалась vararg функция, то в rax должно быть количество xmm-аргументов.
    
    Сохранять: rbx, rbp, r12-r15
    
    Возвращаемое значение: rax или rdx:rax или xmm0 или (xmm0 и xmm1)
    
    Фича: red zone.
    Адреса памяти [esp - 128] ... [esp - 8] никто не тронет (чего в общем случае никто не гарантирует: адреса ниже стека потенциально может кто-нибудь портить).

	// хорошая статья http://www.viva64.com/ru/a/0029/
