Подсказки по кешированию:
    
    movntq
    prefetch
    prefetchw

    prefetch[t0|t1|t2|nta] 

    => Какой-то пиздец. Соль: AMD хотят выпилить 3DNow! и оставить prefetch'и.
    
    maskmovq - читать маны.
    
SSE2 (Pentium 4)

Теперь регистры  можно трактовать как 2 double precision (суффиксы sd|pd)
Можно использовать для xmm-регистров (регистров, добавленных в SSE) mmx-команды.
Профит: теперь сопроцессор совсем не нужен.

Арифметика в qword:
    paddq|psubq
    
    movdq - double qword
    
    pshufw - тут не работает, вместо нее три команды:
        pshuf(l|h)w - только для low|high половины xmm
        phufd - переставляет dword
        
    punpck(l|h)qdq
    
    ps(r|l)ldq - сдвиг в байтах

    movnt(pd|dq|i)
    (l|m)fence - страшная вещь, нужно думать, прежде чем использовать

    pause - ничего не делать, да помедленнее

SSE3 (в поздних вариациях Pentium 4)
Еще плюшечки для плавающих точек.

    * = (ps|pd)

    addsub* - сложить младшие, вычитать старшие
        ООООЧЕНЬ нужно, используется для комплексной арифметики.
    hadd* - горизонтальное сложение
    hsub* - горизонтальное вычитание
    lddqv - (аналог movdqv)
    movddup - раскопировать на весь регистр
    mov(h|l)dup
    
    Для сопроцессора:
    fisttp - заргузить целую часть вершины стека в память, округляя к нулю

SSSE3 (Core 2)

    psign(b|w|d) - изменяет знак первого операнда в знак второго
    pabs(b|w|d) - одной командой посчитать модуль
    pmulhrsw - пиздец (Packed Multiply High with Round and Scale) //Input — { A0, A1… }, { B0, B1… } Output — { A0 * B0, A1 * B1… } Аргументы A и B рассматриваются как вектора 16-ти битных знаковых чисел с фиксированной запятой представленных в диапазоне [-1,+1) (то есть 0x4000 это 0.5, а 0xa000 это −0.75 и т. д.), которые перемножаются друг с другом с корректным округлением.

    pmaddubsw - пиздец (умножение знаковых на беззнаковые с последующим сложением соседних)
    pshufb - суперперемешивание, маска - не константа, а xmm-регистр
    palignr - берем два регистра, интерпретируем как одно 256-битное число, вырезаем 128-битную серединку по смещению, указанному третьим аргументом
    
    ph(sub|add)(w|d)
    ph(add|sub)sw
    
SSE4 существует в 3х вариантах

SSE4.1

    Загрузка с расширением нулем|знаком, например.
    
SSE4.2

    Команда для подсчета числа единичных битиков в числе.
    crc32
    
    4 команды для работы со строками.
    Алгоритмы на строках часто непохожи, поэтому команды страшные, и описание каждой не на одну страницу.
    
SSE4A (от AMD)

    Самое нужное: битик "не падать при обращении к невыровненной на 128 бит памяти".
    
Расширение с командами для AES (Advanced Encryption Standard)

SSE5 - не вышло.
У AMD развилось в:
    XOP (всякие плюшки, например, вращение регистра)
    CVT16 (half precision)
    FMA4 (объяснение попозже)

У Intel:
    AVX
        xmm -> ymm (256 бит, xmm - младшая половина)
        + трехоперандные команды (add dest, src1, src2)
        
AVX2 (Выйдет летом)

    ymm можно будет использовать для целочисленной арифметики.

FMA3
    
    Команда для (x * y + z), работает со скоростью умножение => быстрее пары команд.
    Позволяет в 2 раза увеличить красивую циферку флопсов процессора (тут ведь две команды).
    Округление происходит не дважды (команды то две), а один раз.

Отличие FMA3 от FMA4:
    FMA3: результат - один из операндов.
    FMA4: результат тоже указывется, не обязан быть аргументом. Допускается даже два обращения к памяти.

TSX (Transacted extensions)
    Транзакции по памяти. 
