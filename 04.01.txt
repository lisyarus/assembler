SIMD
MMX

Одновременные вычисления наборов данных.
Профит: ускорение до 8ми раз.
Минус: никак не сопоставляется с конструкциями высокоуровневых языков => компиляторы не умеют использовать эти расширения.

8 почти новых регистров: mm0 ... mm7, 64 бита (на самом деле - мантиссы 80-битных r0 ... r7).
Интерпретируется как угодно, интерпретация зависит от команды.

	movq - копировать весь регистр
	movd - копировать младшие 4 байта (можно и регистры общего назначения). Если регистр назначения - mmx, то старшие 4 байта обнуляются.
		Профит:
		movq mm0, mm7
		movd mm7, eax
		Вторая команда может начать работать раньше, чем закончится первая: реально регистров много, и под второй mm7 процессор может выделить новый регистр.

	Остальные команды: src - mmx|mem, dst - mmx
	
	pack(sswb|ssdw|uswb) dst, src - команды упаковки
		ssdw - signed saturation double word
			src, dst - хранят по два dw, которые урезаются до word (если > max, то урезается до max - это насыщение).
		sswb - signed, word -> byte
		uswb - unsigned, word -> byte (unsigned: word интерпретируется как знаковый, byte - как беззнаковый, урезается до [0..255])

	punpack(L|H)(BW|WD|DQ) - команды распаковки (6 штук)
	Никаких проверок и насыщений, просто копирование бит.
		L,H: low, high (используеются младшие/старшие 32 бита регистров)
		Берем определенные L|H 32 бита из каждого регистра, перемешивает по (байту|слову|двойному слову) (63 src dst src dst 0)
		# todo: нормальное объяснение, а лучше - картинка
		// http://www.rz.uni-karlsruhe.de/rz/docs/VTune/reference/vc265.htm - картинка и подробное объяснение

	padd(b|w|d) - независимое сложение byte/word/double word
	padds(b|w) - сложение со знаковым насыщением
	paddus(b|w) - сложение с беззнаковым насыщением

	psub* - аналогично сложению

	pmullw - по 4 слова, в регистр назначения - четыре младших слова
	pmulhw - по 4 слова, в регистр назначения - четыре старших слова

	pmaddwd - по 4 слова, результат - 4 двойных слова, два младших складываются (как и два старших), это пишется в регистр назначения
	# блять, тут нужна картинка
	// http://www.rz.uni-karlsruhe.de/rz/docs/VTune/reference/vc235.htm - картинка + пояснение

	(psll|psrl)(w|d|q) - логические сдвиги
	psra(w|d) - арифметический вправо

	pand, por, pxor - понятно
	pandn - ((not a) and b) (отрицание импликации)

	pcmp(eq|gt)(b|w|d) - независимое сравнение, в регистре назначения соответствующие байты|слова|двойные слова устанавливаются в (false = 0|true = -1)

	emms - пометить все регистры сопроцессора как свободные

3DNow! от AMD - интерпретация mmx-регистров как двух float'ов

SSE (Pentium 3)

SSE-расшитрения MMX
	
	povg(b|w): dst = целая_часть((dst + src + 1) / 2)

	p(max|min)(ub|sw) - максимум|минимум беззнаковых байтов|знаковых слов

	pmulhuw - умножение беззныковых слов и старшие 16 бит в результат

	pinsrw - записать конкретное слово, не трогая остальные
	pextrw - то же самое для извлечения

	psadbw - сумма абсолютных разностей 8 пар байт, получившееся слово в записывает в результат

	pmovmskb - 8 знаковых битов запихиваются как байт в регистр общего назначения

	pshufw - охуенно
	//	Операция :
		DEST[15-0] = (SRC/m64 >> (imm8[1-0] * 16) )[15-0];
		DEST[31-16] = (SRC/m64 >> (imm8[3-2] * 16) )[15-0];
		DEST[47-32] = (SRC/m64 >> (imm8[5-4] * 16) )[15-0];
		DEST[63-48] = (SRC/m64 >> (imm8[7-6] * 16) )[15-0];
		Описание : Команда PSHUFW копирует слова, упакованные в операнде-источнике команды (MMX-регистр или операнд в памяти) в определенные позиции в операнде-назначении (MMX-регистр).  Для каждой позиции в операнде-назначении третий операнд команды (imm8) задает номер копируемого в нее слова из операнда-источника.  Биты 0,1 параметра imm8 задают номер копируемого слова для младшего 16-битного поля операнда-назначения, биты 2, 3 — для следующего, 4,5 — для третьего и 6, 7 — для самого старшего.  Эти биты кодируются обычными двоичными кодами, например код 11b означает, что в соответствующую позицию будет скопировано самое старшее слово из операнда-источника.  

	movntq - запись в память по специальному каналу, минующему кэш
		разные подсистемы работы с памятью => есть шанс прочитать старое значение
	sfence - типа синхронизация // WHILE (NOT(preceding_stores_globally_visible)) WAIT();
	// Команда SFENCE предназначена для обеспечения цельности данных в системах, где доступ к памяти возможен из различных источников (различные процессоры в многопроцессорных системах, видеокарта и т.п.). Эта команда гарантирует, что все предшествовавшие ей операции записи в память будут полностью отработаны, а их результаты станут доступны для чтения всеми имеющими доступ к соответствующей области памяти устройствами.

	prefetch* (адрес) - подсказка процессору "чувак, я скоро буду читать из этого адреса"
		(группа команд)
		Эффективно - nop. Никогда не падает, ничего не меняет. Процессор может на нее забить.
		Современные кэш-подсистемы умеют это делать лучше тебя, %username%.

SSE для float

	xmm0 ... xmm7 - полностью новые 128-битные регистры, ни с кем не пересекаются.
	128 = 4 float'а

	movaps - работает с памятью только если адрес выровнен на 16 байт (иначе - падает)
	movups - работает всегда, но медленнее

	В остальных ps-командах если аргумент - память, то выровненная на 16 байт 

	mov(l|h)ps - медленные и не нужны

	movss - для младших 32-х бит (можно регистры общего назначения)

	*ps - все 4 float'a
	*ss - только младший float

	(add|sub|mul|div|sqrt|rcp|rsqrt|max|min|cmp|and|andn|or|xor)(ps|ss) - заебись
	
	cvt(pi2ps|ps2pi|si2ss|ss2si) (reg, mem|mem, reg)
		i - integer (dword)
		s - single (float)

	cvtt(ps2pi|ss2si) - всегда с округлением к нулю

	unpck(H|L)ps

	shuf(ss|ps) - охуенно
