IBM: 4 линейки, тащить библиотеки - пизда.
=> IBM 360
=> ISA (набор команд IBM 360)
Идея: программно - одинаково, аппаратно - по-разному.
Например: ADD 32-bit: 1 такт 32 бита, 2 такта 16 бит, 4 такта 8 бит
Зачем? Цена, энергопотребление, евреи

Какие бывают архитектуры:

	1)	Стековая - в процэ есть стек. Операции - с элементами вершины стека.
		Большое выражение => не хватает стека => в середине вычисления достал, посчитал, вернул
		Зато просто и удобно, хули
		Говорят, в Java-машине внутри что-то похожее
		А еще в языке FALSE, но на нем на этой планете не пишут

		// c = a + b
		push a
		push b
		add
		pop c

	2)	Один регистр - "аккумулятор". У арифметических операций 1 операнд.
		Память - слоу => всё время обращаться к памяти - слишком грустно
		Бывает в простеньких железках

		// c = a + b
		load a
		add b
		store c

Слегка оффтоп: нужно добавить регистр => что-то не так => наверное все не так => все переделать, поэтому регистры "по одному" не добавляют.

	3)	REG-REG
		У арифметических команд 2-3 операнда, все операнды - регистры.
		Вычисления из регистров в регистры.
		Везде регистры.
		(Можно и грузить из регистра в память или из памяти в регистр).
		Почему 2-3?
			ADD A, B // A += B
			ADD A, B, C // A = B + C
			// Здесь A, B, C - регистры
		Пример: MIPS
		Вполне совеременная архутектура.

		// c = a + b
		mov r0, a
		mov r1, b
		add r0, r0, r1
		mov c, r0

Оффтоп: обращение к памяти - по индексу ячейки, но к регистрам - по имени. 
Если имена - r0, r1, r2, то это все равно имена. rx, где x - откуда-то взятый номер - НЕЛЬЗЯ.

	4)	REG-MEM - один из операндов может быть обращением к памяти.
		Пример - православный x86.
		
		// c = a + b
		mov r0, a
		add r0, r0, b
		mov c, r0		

Бывает и больше обращений к памяти в команде, но так дела не делаются, ибо сложно пиздец.

К командам обычно добавляют макросы-шмакросы в духе оных в gcc. Не темплейты плюсовые, но все равно годно.
.\_/.

Intel впереди остальных поколения так на полтора.
ARM свободно лицензируемый, любой китаец в сарае может собрать.
Неплохо так соревнуются по энергопотреблению.

Рзработочка Intel - Pentium, работающий от небольших солнечных батарей.
Один из вариантов девайсов будущего - работает так себе, но работает. Подключаешь в нормальную сеть - ускоряется раз эдак в 50.

CISC и RISC

(complete / redused) instruction set computer?

	CISC: 
		В последних x86, например, есть команда CRC32, считающая CRC32, не поверите, одной командой
		Или вот, например:
			ADD EAX, [EBX + ECX * 4 + 10]
		Взять EBX, прибавить ECX, умноженный на 4, прибавить еще 10, пойти по полученному адресу, считать, прибавить к EAX

	RISC:
		Немного команд, простая адресация, но все еще тьюринг-полный.
		(почти-)фиксированный размер команд в байтах, чем CISC ну совсем не похвастается.

В x86 сделать одну команду длиной в пару десятков байт - без проблем.
Но договорились, что ДАВАЙТЕ ТАК НЕ БУДЕМ ДЕЛАТЬ.
Команды больше 15 байт - зло, сжигать на кострах.
Плавающая длина команд => если хотим выполнять несколько команд одновременно - нам грустно.
	Потому что где начинается следующая, не поймешь без рюмки.
	Или предварительного, а не одновременного, парсинга команд, что тоже грустно.

Статья "Рывок Кентавра, или разгон процессора VA" (или VIA, хуй его знает)

=====================================================================================================================

Итак, x86, 32 битный (64 будет позже).

	EAX	= AX + 16 бит, AX = AL + AH
	ECX	= CX + 16 бит, CX = CL + CH
	EDX	= DX + 16 бит, DX = DL + DH
	EBX	= BX + 16 бит, BX = BL + BH
	EBP	= BP + 16 бит
	ESP	= SP + 16 бит
	ESI	= SI + 16 бит
	EDI	= DI + 16 бит

	EFLAGS	= FLAGS + чуть больше, видимо
	Сам по себе не интересен, содержит битовые флаги.

	ZF	- zero flag, устанавливается, если в результате последней операции получился 0.
	CF	- carry flag, если был перенос из самого старшего операции.
	SF	- sign flag, если получилось < 0.
	DF	- прослушал, поэтому хуй

	EIP	- адрес выполняемой команды, напрямую юзать нельзя. Да и не напрямую тоже. Это процессор, а не плюсы, здесь нет магии.
		upd: нет, магия таки есть. Хотя это уже не магия, а анальная боль. (_._)

Няша рекомендует YASM. Рекомендует - значит умри, но используй его.
16 bit: несерьезно, Microsoft выпилило поддержку 16-битных программ, зато можно сделать операционку ^_^
32 bit: не бывает чистый, только под конкретную ось
64 bit: будет много позже

Компиляция:

	yasm -f win32
	yasm -f elf

	win32 - под винду
	elf - под линухи

Линковка:

	link /subsystem console /libpath defaultlibkernel32.lib /entry start
	link /subsystem windows /libpath defaultlibkernel32.lib /entry start

	console - будет сразу окошечко консоли
	windows - не будет

	НУЖНО УКАЗАТЬ ПРАВИЛЬНЫЕ БИБЛИОТЕКИ, МУДИЛА
