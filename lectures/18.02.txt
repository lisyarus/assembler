Исходно регистры пиздец ассиметричны и специализированы. Сегодня уже получше, но все еще остались костыли из-за ISA (спецификации набора команд).

Командочки:

    mov eax, ebx // eax := ebx
    только регистры одного размера

    movzx eax, cx // eax := cx
    копирование с расширением нулями

    movsx eax, cx // eax := cx
    копирование с расширением знаковым битом

    mov{условие} {регистр}, {регистр / константа}
        Условия:
            Z - флаг нуля
            NZ - нет флага нуля
            и другие

    xchg eax, ebx // swap

    bswap eax // меняет порядок байт (little endian -> big endian или наоборот)

Поговорим об адресации, т.е. о том, как мы можем адресовать память.

16 bit:
    [bx / bp] + [si / di] + [offset: 16 bit]
    Как минимум одно слагаемое из этих трех.

32 bit:
    [eax / ebx / ecx / edx / eebp / esp / esi / edi]
    + [те же, кроме esp] * [1 / 2 / 4 / 8]
    + [offset: 32 bit]
 
yasm умняш и распарсит [eax * 3] в [eax + eax * 2]

    lea eax, [eax + ebx * 4] // вычислит адрес во втором аргументе, и запишет сам адрес в eax

    push eax // записать на стек
        sub esp, 4;
        mov, [esp], eax
    
    pop ebx // считать со стека
        mov ebx, [esp]
        add esp, 4

    Для команд стека можно брать и 16-битные аргументы. Тогда esp сместится на 2 байта, а не на 4.

    pusha // запихать все 8 16-битных регистров общего назначения на стек
    pushad // запихать все 8 32-битных регистров общего назначения на стек 
    popa, popad // считать со стека. Записанный ранее esp пропускается.

    
    cwd // заполняет dx знаковым битом ax
    cdq // заполняет edx знаковым битом eax
    
    cbw // заполняет ? знаковым битом ?
    ???    

    add eax, ebx // eax += ebx
    adc eax, ebx // eax += ebx + CF (флаг переноса)

    sub eax, ebx // eax -= ebx
    sbb eax, ebx // eax -= ebx + CF

    neg eax // инвертировать знак числа

    cmp eax, ebx // = sub, но не использует результат, только ставит

    inc eax // eax += 1
    dec eax // eax -= 1
    эти не меняют флаг переноса

    mul op8 (8-битный операнд)
        // ax = al * op8
    mul op16 (16-битный операнд)
        // dx:ax = ax * op16        
    mul op32 (32-битный операнд)
        // edx:eax = eax * op32
    imul - то же самое, только со знаком

    div op32
        // eax = (edx:eax) / op32
        // edx = (edx:eax) % op32
        // если результат деления > 32 бит (или деление на ноль), то кидается аппаратное исключение "деление на ноль" и пиздец
    div op16, div op8 - симметрично умножению
    idiv - со знаком

    Особые формы imul:
    imul eax, ebx // eax *= ebx, только младшие 32 бита результата
    imul eax, ebx, c // eax = ebx * c, только константа, так же только младшие 32 бита

    not ebx
    and/or/xor ebx, eax
    test eax, ebx // как and, но не использует результат, только выставляет флаги

Няша рекомендует читать оффициальные доки по командам. Говорят, на вики есть прямые ссылки на оные.
    
    shr/shl eax, 2 // сдвиг направо/налево, работают с константой или с регистром cl
    sar // сдвигает с копированием знака

    shrd/shld // три операнда - читать документацию

    rol/ror // вращение бит налево/направо
    rcl/rcr // вращение + приписка к регистру флага переноса
    
    nop // ничего не делает (90h - аппаратное прерывание в x86)
        // аппаратно это xchg eax, eax
    
    int3 // вызов отладчика
    ud2 // команда, которой гарантированно не существует, и она гарантированно кинет исключение "недопустимая команда"

    jmp {label/addr} // безусловный переход
    j{условие} {label/addr} // условный переход
        Условия:
            ... (уже было выше)
            без знака:
            a (above: первый аргумент команды cmp был больше)
            e (equal: первый аргумент равен второму)
            b (below: первый аргумент меньше)
            ae = nb (above or equal = not below)
            
            со знаком: l (less), g (greater)

    call {label/addr} // записать ip на стек, потом jmp
    ret // считать ip со стека, вернуться туда
    ret N // ret, плюс убрать N байт со стека
